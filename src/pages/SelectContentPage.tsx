import { useState, useEffect, useMemo } from "react";
import { useNavigate } from "react-router-dom";
import { motion, AnimatePresence } from "framer-motion";
import { ArrowLeft, Check, Dumbbell, Utensils, ChefHat, Calendar, Loader2, ChevronDown, ChevronRight } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "@/hooks/useAuth";
import { format } from "date-fns";
import { Json } from "@/integrations/supabase/types";

type ContentType = "all" | "workout" | "meal" | "recipe" | "routine";

interface ContentItem {
  id: string;
  type: ContentType;
  title: string;
  subtitle: string;
  data: Record<string, unknown>;
  created_at: string;
}

const contentTypeConfig = {
  workout: { icon: Dumbbell, label: "Workouts", gradient: "from-primary to-accent" },
  meal: { icon: Utensils, label: "Meals", gradient: "from-success to-emerald-400" },
  recipe: { icon: ChefHat, label: "Recipes", gradient: "from-rose-500 to-pink-400" },
  routine: { icon: Calendar, label: "Routines", gradient: "from-violet-500 to-purple-400" },
};

// Generate a workout name based on time of day
const generateWorkoutName = (createdAt: string) => {
  const hour = new Date(createdAt).getHours();
  if (hour < 12) return "Morning Workout";
  if (hour < 17) return "Afternoon Workout";
  return "Evening Workout";
};

const SelectContentPage = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const [filter, setFilter] = useState<ContentType>("all");
  const [selectedItem, setSelectedItem] = useState<ContentItem | null>(null);
  const [content, setContent] = useState<ContentItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [expandedItems, setExpandedItems] = useState<Set<string>>(new Set());

  const toggleExpanded = (id: string, e: React.MouseEvent) => {
    e.stopPropagation();
    setExpandedItems(prev => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  };

  useEffect(() => {
    if (!user) return;

    const fetchUserContent = async () => {
      setIsLoading(true);
      try {
        const items: ContentItem[] = [];

        // Fetch workouts
        const { data: workouts } = await supabase
          .from("workout_logs")
          .select("*")
          .eq("user_id", user.id)
          .order("created_at", { ascending: false });

        workouts?.forEach((w) => {
          const rawExercises = w.exercises as unknown;
          const exercises = Array.isArray(rawExercises)
            ? (rawExercises as Array<{ name: string }>)
            : [];

          // Skip workouts with 0 exercises
          if (exercises.length === 0) return;

          // Use workoutTitle from notes if it exists, otherwise generate a name
          const workoutData = w as Record<string, unknown>;
          const storedTitle = (workoutData.notes as string)?.startsWith("__TITLE__")
            ? (workoutData.notes as string).replace("__TITLE__", "").split("__NOTES__")[0]
            : null;
          const workoutTitle = storedTitle || generateWorkoutName(w.created_at);

          items.push({
            id: w.id,
            type: "workout",
            title: workoutTitle,
            subtitle: `${exercises.length} exercises • ${format(new Date(w.created_at), "MMM d")}`,
            data: {
              exercises,
              notes: w.notes,
              photos: w.photos,
              workoutTitle: workoutTitle,
              isAutoGeneratedName: !storedTitle,
            },
            created_at: w.created_at,
          });
        });

        // Fetch saved meals (user-created saved meals only, not meal logs)
        const { data: savedMeals } = await supabase
          .from("posts")
          .select("*")
          .eq("user_id", user.id)
          .eq("content_type", "saved_meal")
          .order("created_at", { ascending: false });

        savedMeals?.forEach((m) => {
          const data = m.content_data as Record<string, unknown>;
          const foods = data.foods as Array<{ name: string }>;
          items.push({
            id: m.id,
            type: "meal",
            title: (data.name as string) || "Saved Meal",
            subtitle: `${foods?.length || 0} items • ${format(new Date(m.created_at), "MMM d")}`,
            data: {
              name: data.name,
              mealType: "saved_meal",
              foods: data.foods,
              tags: data.tags,
              totalCalories: data.totalCalories,
              totalProtein: data.totalProtein,
              totalCarbs: data.totalCarbs,
              totalFats: data.totalFats,
            },
            created_at: m.created_at,
          });
        });

        // Fetch recipes from posts
        const { data: recipes } = await supabase
          .from("posts")
          .select("*")
          .eq("user_id", user.id)
          .eq("content_type", "recipe")
          .order("created_at", { ascending: false });

        recipes?.forEach((r) => {
          const data = r.content_data as Record<string, unknown>;
          items.push({
            id: r.id,
            type: "recipe",
            title: (data.title as string) || "Recipe",
            subtitle: `${(data.ingredients as Array<unknown>)?.length || 0} ingredients • ${format(new Date(r.created_at), "MMM d")}`,
            data: data,
            created_at: r.created_at,
          });
        });

        // Fetch routines from scheduled_routines
        const { data: routines } = await supabase
          .from("scheduled_routines")
          .select("*")
          .eq("user_id", user.id)
          .order("created_at", { ascending: false });

        // Group routines by post_id to avoid duplicates
        const routineMap = new Map<string, typeof routines[0]>();
        routines?.forEach((r) => {
          if (!routineMap.has(r.routine_name)) {
            routineMap.set(r.routine_name, r);
          }
        });

        routineMap.forEach((r) => {
          const data = r.routine_data as { exercises?: Array<unknown> };
          items.push({
            id: r.id,
            type: "routine",
            title: r.routine_name,
            subtitle: `${data.exercises?.length || 0} exercises • ${r.day_of_week}`,
            data: {
              routineName: r.routine_name,
              exercises: data.exercises,
              scheduleDays: [r.day_of_week],
              recurring: r.recurring,
            },
            created_at: r.created_at,
          });
        });

        // Sort by date
        items.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
        setContent(items);
      } catch (error) {
        console.error("Error fetching content:", error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchUserContent();
  }, [user]);

  const filteredContent = useMemo(() => {
    if (filter === "all") return content;
    return content.filter((item) => item.type === filter);
  }, [content, filter]);

  const handleNext = () => {
    if (!selectedItem) return;
    navigate("/share", {
      state: {
        contentType: selectedItem.type,
        contentData: selectedItem.data,
        images: [],
        returnTo: "/select-content",
        fromSelection: true,
      },
      replace: true,
    });
  };

  const handleSkip = () => {
    navigate("/share", {
      state: {
        contentType: "post",
        contentData: {},
        images: [],
        returnTo: "/select-content",
        fromSelection: true,
      },
      replace: true,
    });
  };

  const typeFilters: { value: ContentType; label: string }[] = [
    { value: "workout", label: "Workouts" },
    { value: "meal", label: "Meals" },
    { value: "recipe", label: "Recipes" },
    { value: "routine", label: "Routines" },
  ];

  const selectedTypeLabel = filter === "all" 
    ? null 
    : typeFilters.find(f => f.value === filter)?.label;

  const renderDetailedView = (item: ContentItem) => {
    if (item.type === "workout") {
      const exercises = item.data.exercises as Array<{ name: string; sets?: Array<{ weight?: number; reps?: number }> }>;
      return (
        <div className="mt-3 pt-3 border-t border-border space-y-2">
          {exercises?.map((exercise, idx) => (
            <div key={idx} className="flex items-center justify-between text-sm">
              <span className="text-muted-foreground">{exercise.name}</span>
              <span className="text-xs text-muted-foreground">
                {exercise.sets?.length || 0} sets
              </span>
            </div>
          ))}
        </div>
      );
    }
    
    if (item.type === "meal") {
      const foods = item.data.foods as Array<{ name: string; calories?: number }>;
      return (
        <div className="mt-3 pt-3 border-t border-border space-y-2">
          {foods?.map((food, idx) => (
            <div key={idx} className="flex items-center justify-between text-sm">
              <span className="text-muted-foreground">{food.name}</span>
              {food.calories && (
                <span className="text-xs text-muted-foreground">{food.calories} cal</span>
              )}
            </div>
          ))}
        </div>
      );
    }

    if (item.type === "recipe") {
      const ingredients = item.data.ingredients as Array<{ name: string }>;
      return (
        <div className="mt-3 pt-3 border-t border-border space-y-2">
          <p className="text-xs text-muted-foreground mb-1">Ingredients:</p>
          {ingredients?.slice(0, 5).map((ing, idx) => (
            <div key={idx} className="text-sm text-muted-foreground">
              • {typeof ing === 'string' ? ing : ing.name}
            </div>
          ))}
          {ingredients && ingredients.length > 5 && (
            <p className="text-xs text-muted-foreground">+{ingredients.length - 5} more</p>
          )}
        </div>
      );
    }

    if (item.type === "routine") {
      const exercises = item.data.exercises as Array<{ name: string }>;
      return (
        <div className="mt-3 pt-3 border-t border-border space-y-2">
          {exercises?.map((exercise, idx) => (
            <div key={idx} className="text-sm text-muted-foreground">
              {exercise.name}
            </div>
          ))}
        </div>
      );
    }

    return null;
  };

  return (
    <div className="min-h-screen bg-background flex flex-col">
      <motion.div
        initial={{ opacity: 0, x: 20 }}
        animate={{ opacity: 1, x: 0 }}
        exit={{ opacity: 0, x: -20 }}
        className="p-4 flex-1"
      >
        {/* Header */}
        <div className="flex items-center justify-between mb-6">
          <div className="flex items-center gap-4">
            <Button variant="ghost" size="icon" onClick={() => navigate("/")}>
              <ArrowLeft size={24} />
            </Button>
            <h1 className="text-2xl font-bold">Select Content</h1>
          </div>
          <Button
            onClick={selectedItem ? handleNext : handleSkip}
            className="px-6"
          >
            {selectedItem ? "Next" : "Skip"}
          </Button>
        </div>

        {/* Filter Options */}
        <div className="flex gap-2 mb-4">
          <Button
            variant={filter === "all" ? "default" : "outline"}
            size="sm"
            onClick={() => setFilter("all")}
          >
            All
          </Button>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button 
                variant={filter !== "all" ? "default" : "outline"} 
                size="sm" 
                className="gap-2 flex-1 justify-between"
              >
                {selectedTypeLabel || "Select Type"}
                <ChevronDown size={16} />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="start" className="bg-popover">
              {typeFilters.map((f) => (
                <DropdownMenuItem
                  key={f.value}
                  onClick={() => setFilter(f.value)}
                  className={filter === f.value ? "bg-accent" : ""}
                >
                  {f.label}
                </DropdownMenuItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>

        {/* Content List */}
        {isLoading ? (
          <div className="flex items-center justify-center py-20">
            <Loader2 className="animate-spin text-muted-foreground" size={32} />
          </div>
        ) : filteredContent.length === 0 ? (
          <div className="text-center py-20 text-muted-foreground">
            <p>No content found</p>
            <p className="text-sm mt-2">Create some workouts, meals, or recipes first!</p>
          </div>
        ) : (
          <div className="space-y-3">
            <AnimatePresence>
              {filteredContent.map((item) => {
                const config = contentTypeConfig[item.type as keyof typeof contentTypeConfig];
                const Icon = config?.icon || Dumbbell;
                const isSelected = selectedItem?.id === item.id;
                const isExpanded = expandedItems.has(item.id);

                return (
                  <motion.div
                    key={item.id}
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -10 }}
                    className={`w-full p-4 rounded-2xl border text-left transition-all ${
                      isSelected
                        ? "border-primary bg-primary/10"
                        : "border-border bg-card hover:border-primary/50"
                    }`}
                  >
                    <div 
                      className="flex items-center gap-4 cursor-pointer"
                      onClick={() => setSelectedItem(isSelected ? null : item)}
                    >
                      <div className={`w-12 h-12 rounded-xl bg-gradient-to-br ${config?.gradient} flex items-center justify-center shrink-0`}>
                        <Icon size={24} className="text-primary-foreground" />
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="font-semibold truncate">{item.title}</p>
                        <p className="text-sm text-muted-foreground truncate">{item.subtitle}</p>
                      </div>
                      <button
                        onClick={(e) => toggleExpanded(item.id, e)}
                        className="w-8 h-8 rounded-full flex items-center justify-center hover:bg-muted transition-colors shrink-0"
                      >
                        <motion.div
                          animate={{ rotate: isExpanded ? 90 : 0 }}
                          transition={{ duration: 0.2 }}
                        >
                          <ChevronRight size={18} className="text-muted-foreground" />
                        </motion.div>
                      </button>
                      {isSelected && (
                        <div className="w-8 h-8 rounded-full bg-primary flex items-center justify-center shrink-0">
                          <Check size={18} className="text-primary-foreground" />
                        </div>
                      )}
                    </div>
                    <AnimatePresence>
                      {isExpanded && (
                        <motion.div
                          initial={{ opacity: 0, height: 0 }}
                          animate={{ opacity: 1, height: "auto" }}
                          exit={{ opacity: 0, height: 0 }}
                          transition={{ duration: 0.2 }}
                        >
                          {renderDetailedView(item)}
                        </motion.div>
                      )}
                    </AnimatePresence>
                  </motion.div>
                );
              })}
            </AnimatePresence>
          </div>
        )}
      </motion.div>
    </div>
  );
};

export default SelectContentPage;
